using System;
using System.Diagnostics;
using System.Linq;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Diagnostics;
using Microsoft.CodeAnalysis.Text;
using Orleans;
using Orleans.CodeGenerator;

namespace Devlooped.CloudActors;

public record OrleansGeneratorOptions(Compilation Compilation, CSharpParseOptions? ParseOptions, AnalyzerConfigOptions AnalyzerConfig)
{
    public bool IsCloudActorsServer => AnalyzerConfig.TryGetValue("build_property.IsCloudActorsServer", out var value) &&
        bool.TryParse(value, out var isServer) && isServer;
}

public static class OrleansGeneratorExtensions
{
    public static IncrementalValueProvider<OrleansGeneratorOptions> GetOrleansOptions(this IncrementalGeneratorInitializationContext context)
        => context.CompilationProvider
            .Combine(context.AnalyzerConfigOptionsProvider.Select((x, _) => x.GlobalOptions))
            .Combine(context.ParseOptionsProvider)
            .Select((x, _) => new OrleansGeneratorOptions(x.Left.Left, x.Right as CSharpParseOptions, x.Left.Right));
}

/// <summary>
/// Runs the equivalent of the Orleans generator. This allows us to detect the presence of the 
/// original generator and fail in that case since we might end up with duplicate code.
/// </summary>
//[Generator(LanguageNames.CSharp)]
public class OrleansGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var processName = Process.GetCurrentProcess().ProcessName.ToLowerInvariant();
        if (processName.Contains("devenv") || processName.Contains("servicehub"))
            return;

        var options = context.GetOrleansOptions();

        context.RegisterImplementationSourceOutput(options, (ctx, orleans) =>
        {
            var options = CreateGeneratorOptions(orleans);
            var generator = new CodeGenerator(
                orleans.Compilation.WithAssemblyName($"{orleans.Compilation.AssemblyName}.OrleansGenerator"), options);
            var syntax = generator.GenerateCode(ctx.CancellationToken);
            var code = syntax.NormalizeWhitespace().ToFullString();
            var text = SourceText.From(code, Encoding.UTF8);

            ctx.AddSource($"{orleans.Compilation.AssemblyName ?? "assembly"}.orleans.g.cs", text);
        });
    }

    public static string GenerateCode(OrleansGeneratorOptions orleans, string additionalCode, string? additionalName = default, CancellationToken cancellation = default)
    {
        var options = CreateGeneratorOptions(orleans);

        var additionalSyntax = CSharpSyntaxTree.ParseText(additionalCode, orleans.ParseOptions);
        var compilation = orleans.Compilation.AddSyntaxTrees(additionalSyntax);

        if (additionalName == null)
        {
            var declaration = additionalSyntax.GetRoot().DescendantNodes().OfType<TypeDeclarationSyntax>().FirstOrDefault();
            if (declaration != null)
                additionalName = declaration.Identifier.Text;
        }

        // The assembly name is used as the namespace for the generated metadata type, we need to change it 
        // to avoid emitting multiple types with the same full name.
        compilation = compilation.WithAssemblyName($"{compilation.AssemblyName}.{additionalName}");

        var generator = new CodeGenerator(compilation, options);
        var syntax = generator.GenerateCode(cancellation);

        syntax = syntax.RemoveNodes(
            syntax.DescendantNodes()
                .OfType<AttributeSyntax>()
                .Where(attr => attr.Name.ToString().Contains("Orleans.ApplicationPartAttribute"))
                // Remove the whole [assembly: ...] attribute list
                .SelectMany(attr => attr.Ancestors().OfType<AttributeListSyntax>())
            , SyntaxRemoveOptions.KeepNoTrivia);

        var source = syntax!.NormalizeWhitespace().ToFullString();

        return
            $"""
            // <auto-generated/>
            #nullable enable annotations
            #nullable disable warnings
            {source}
            """;
    }

    static CodeGeneratorOptions CreateGeneratorOptions(OrleansGeneratorOptions orleans)
    {
        var options = new CodeGeneratorOptions();
        if (orleans.AnalyzerConfig.TryGetValue("build_property.orleans_immutableattributes", out var immutableAttributes) && immutableAttributes is { Length: > 0 })
        {
            options.ImmutableAttributes.AddRange([.. immutableAttributes.Split([';'], StringSplitOptions.RemoveEmptyEntries)]);
        }

        if (orleans.AnalyzerConfig.TryGetValue("build_property.orleans_aliasattributes", out var aliasAttributes) && aliasAttributes is { Length: > 0 })
        {
            options.AliasAttributes.AddRange([.. aliasAttributes.Split([';'], StringSplitOptions.RemoveEmptyEntries)]);
        }

        if (orleans.AnalyzerConfig.TryGetValue("build_property.orleans_idattributes", out var idAttributes) && idAttributes is { Length: > 0 })
        {
            options.IdAttributes.AddRange([.. idAttributes.Split([';'], StringSplitOptions.RemoveEmptyEntries)]);
        }

        if (orleans.AnalyzerConfig.TryGetValue("build_property.orleans_generateserializerattributes", out var generateSerializerAttributes) && generateSerializerAttributes is { Length: > 0 })
        {
            options.GenerateSerializerAttributes.AddRange([.. generateSerializerAttributes.Split([';'], StringSplitOptions.RemoveEmptyEntries)]);
        }

        if (orleans.AnalyzerConfig.TryGetValue("build_property.orleans_generatefieldids", out var generateFieldIds) && generateFieldIds is { Length: > 0 })
        {
            if (Enum.TryParse(generateFieldIds, out GenerateFieldIds fieldIdOption))
            {
                options.GenerateFieldIds = fieldIdOption;
            }
        }

        if (orleans.AnalyzerConfig.TryGetValue("build_property.orleansgeneratecompatibilityinvokers", out var generateCompatInvokersValue)
            && bool.TryParse(generateCompatInvokersValue, out var genCompatInvokers))
        {
            options.GenerateCompatibilityInvokers = genCompatInvokers;
        }

        return options;
    }
}
